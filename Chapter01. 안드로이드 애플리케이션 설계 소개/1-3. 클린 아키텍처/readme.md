- 클린 아키텍처
	- 로버트 C. 마틴에 의해 만들어진 철학으로, 소프트웨어의 관심사를 계층별로 분리하는 소프트웨어 디자인 철학
	- 주요 원칙은 코드종속성이 외부로부터 내부로 의존한다는 것
		- 내부 계층의 코드는 외부 계층의 기능을 알 수 없다.
		- 외부 계층에 존재하는 변수, 함수 및 클래스는 안쪽 계층에서 다시 등장할 수 없다.
		- 데이터 형식도 계층간에 별도로 유지하는 것이 좋다.
	- Entities는 가장 추상적인 영역이다.
		- 비즈니스 로직을 포함하고 사용중인 프레임워크에 의존해서는 안된다.
		- 외부 원은 네트워크 및 DB의 접근처럼 구체적인 구현 세부사항이 포함된다.
	- 장점은 계층을 분리하고 계층 간의 의존성을 단방향으로 만들기 때문에 코드의 재사용성이 용이해지고, 유닛 테스트가 쉬워진다.
	- 기본적인 의존성 규칙은 내부 계층은 외부 계층을 알면 안된다는 것
		- 이것만 지킨다면 계층을 몇개로, 어떻게 나누어도 크게 상관 없다.

- Entities
	- 엔터티는 전반적인 비즈니스 규칙을 캡슐화한다
		- 뭐라고?
		- 데이터의 구조나 메서드를 포함하는 객체이다.
		- 전반적으로 많은 애플리케이션 사이에서 사용될 수 있다.
	- 하나의 앱을 위한 엔터티라면 앱의 비즈니스 로직을 담고 가장 일반적이고 상위 수준의 규칙들을 캡슐화한다.
		- 외부에서 무언가 변경되었을 때 가장 최소한의 변경 사항을 가져야만 한다.
		- 예를 들어 화면의 이동, 보안과 관련된 내용이 변경되어도 엔터티 계층은 영향을 받으면 안된다
	- 네트워크나 DB와 관련된 클래스를 작성할 때 POJO와 같은 데이터 클래스도 이 계층에 속한다
		- POJO가 뭔지 검색해도 잘 모르겠삼
		- 어쨌든 이런 데이터클래스는 앱과 관련된 코드를 포함해서는 안된다.
		- 순수한 코틀린 코드일 때 유닛 테스트가 수월해진다.

- Use Cases
	- 앱과 관련된 비즈니스 규칙을 포함하고 시스템의 모든 유스케이스 구현체들을 캡슐화한다.
	- 엔터티로부터의 데이터 흐름들을 관리하고, 엔터티에게 넓고 전사적인 비즈니스 로직의 사용을 가르친다,
	- 관심사를 분리했으므로 이 계층은 엔터티에 영향을 미치거나 외부 계층에서 영향을 받지 않는다
	- 안드로이드에서는 Model, Repository, Executor 등과 관련된 내용이 이 계층에 속한다.
	- Model : DB 쿼리나 네트워크 요청등의 비즈니스 로직을 수행
	- Repository : 내부 DB에 접근하거나 저장 또는 원격 서버의 데이터를 요청한다.
	- Executor : 위 2개와 관련된 작업이 백그라운드에서 수행할 수 있도록 스레드를 관리하고 제공한다.

- Interface Adapters
	- 유스케이스나 엔터티로부터 얻은 데이터를 가공하는 계층이다.
	- 비즈니스 로직을 수행하여 원하는 결과값을 얻어 UI에 표현하기 위해 적당한 형식으로 데이터를 변경한다.
	- 아키텍쳐 디자인 패턴에서 흔히 말하는 Presenter, View, ViewModel, Controller 같은 관심사가 여기에 속한다.
	- 반대로 UI로 부터 얻은 데이터를 DB나 서버에 전송할 때도 이 계층에서 데이터를 가공하여 전달한다.
	- 이 계층의 목적은 비즈니스 로직과 프레임워크 코드를 자연스럽게 연결하는 것이다.

- Frameworks $ Drivers
	- 안드로이드에서는 UI와 관련된 액티비티, 프래그먼트, 인텐트, DB, 콘텐츠 프로바이더, retrofit 같은 프레임워크 코드가 포함된다.
	- 일반적으로 앱 개발자가 프레임워크 코드를 수정할 일은 많지 않다.
	- 관심사가 분리된 코드를 사용하면 많은 소프트웨어가 방해받지 않고 특정 문제에 집중할 수 있다.
	- 클린 아키텍처는 SOLID 원칙을 잘 따른 일종의 모범 패턴이다.
	- 클린 아키텍처에 정답은 없다. 상황에 따라 조금씩 다른 형태를 가질 수 있다.
	- 하지만 원칙은 변하지 않는다. 원칙을 잘 따르면 많은 문제점을 해결하고 더 나은 결과물을 만들 수 있다.


