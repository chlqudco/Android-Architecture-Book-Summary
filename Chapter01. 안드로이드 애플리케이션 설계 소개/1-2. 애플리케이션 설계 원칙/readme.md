- 애플리케이션 설계 원칙
	- 어떤 원칙을 정하고 이것을 기반으로 프로그래밍 한다면 원칙 없이 작성한 코드보다는 더 나은 결과물을 볼 수 있을 것이다.
	- 로버트 C. 마틴이 제시한 SOLID 원칙을 배워보자
		- 객체 지향 프로그래밍 및 설계에 대한 5가지 원칙이다.
		- 유지 보수와 확장이 쉬운 앱을 만들기 위해 이 원칙을 적용하면 좋다.
		- 코드의 가독성이 높아지고 확장이 쉬운 구조를 만드는 지침이다.

- 단일 책임 원칙
	- Single Responsibility Principle
	- 모든 클래스는 하나의 책임만 가지며 그 책임을 완전히 캡슐화해야 함.
	- 단일 책임은 어떤 클래스나 메서드가 단 하나의 기능을 가져야 한다는 뜻이다.
		- 따라서 변경 사항이 발생하더라도 그 변경사항에 대한 책임이 있는 부분만 수정하면 됨
	- 예를 들어 데이터를 분석하고 서버에 전송하는 모듈을 생각해보자.
		- 이 모듈은 데이터 분석 알고리즘 때문에 변경되거나 서버 전송 형식 때문에 변경될 수 있다.	
		- 이 문제들은 분리된 책임이기 때문에 분리된 클래스로 나눠야 한다.
	- 이것이 중요한 이유는 이 원칙이 클래스를 더욱 튼튼하게 하기 때문이다.
		- 스파게티 코드는 하나의 변경으로 다른 부분이 영향을 받아서 앱 자체가 망가질 위험이 높다.

- 개방 폐쇄 원칙 (Open Closed Principle)
	- 소프트웨어가 확장에 대해서는 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 원칙
	- 이 원칙은 시스템의 구조를 올바르게 구성하여 변경사항이 발생하더라도 다른 코드나 모듈에 영향이 없도록 하는 것이다.
		- 만약 어떤 내용을 수정하기 위해 연관된 다른 코드나 모듈까지 수정하는 것은 어렵고 난감한 일이다.
		- 따라서 이 원칙이 잘 적용된 경우, 새로운 기능을 추가하거나 기존 기능을 변경하기가 용이해진다.
	- 객체 지향 프로그래밍의 핵심 원칙이다.
		- 이 원칙을 무시한다고 해서 구현이 불가능 한것은 물론 아니다
		- 그러나 잘 따른다면 객체 지향 프로그램ㅇ의 최대 장점인 유연성, 재사용성, 유지 보수성을 얻을 수 있다.
		- 따라서 이 원칙은 바드시 지켜야 할 기본적인 원칙이다.

- 리스코프 치환 원칙 (Liskov Substitution Principle)
	- 치환성은 객체 지향 프로그래밍의 원칙이다
		- 클래스 S가 클래스 T의 자식 클래스 라면 별다른 변경없이 부모 클래스 T를 자식 클래스 S로 치환할수 있어야 한다는 원칙이다.
		- 즉, 다운 캐스팅된 인스턴스가 논리적으로 그 역할이 문제 없어야 한다.

- 인터페이스 분리 원칙 (Interface Segregation Principle)
	- 어떠한 클래스가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙.
	- 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리함으로써 클래스들이 꼭 필요한 메서드들만 이용할 수 있도록 해야 한다.
	- 이 원칙을 이용해 시스템의 내부 의존성을 약화해 리팩토링, 수정, 재배포를 쉽게 할 수 있다.

- 의존 역전 원칙 (Dependency Inversion Principle)
	- 모듈들을 분리하는 특정 형식을 지칭한다.
		- 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 역전시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.
	- 첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다.
		- 두 모듈 모두 추상화에 의존해야 한다.
	- 둘째, 추상화는 세부 사항에 의존해서는 안 된다.
		- 세부사항이 추상화에 의존해야 한다.
	- 이 원칙은 상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다는 객체 지향 설계의 대원칙을 제공한다.
	- 충전기 예시
		- 이전 휴대폰들은 대부분 전용 충전기나 크레이들이 있었다. 따라서 다른 기종의 충전기로는 충전할 수 없었다.
		- 어떤 기기가 단 한가지 종류의 전용 충전기에만 충전되고 다른 충전기는 호환되지 않는다면 이 기기는 전용 충전기에 강한 의존성을 가진다고 말한다.
		- 그러나 요즘은 C 타입 단자라면 어느 제조사의 충전기를 끼워도 충전이 잘 된다.
		- 따라서 요즘 기기는 충전기에 대한 약한 의존성을 갖는다고 말할 수 있다. 굳이 특정 충전기가 아니여도 되기 때문이다.
		- 코드 관점으로 보면 C 타입이란 계층을 인터페이스로 구현한 뒤 충전기가 C 타입을 상속받게 한다.
		- 기기가 특정 충전기에 의존하던 것을 인터페이스를 통해 의존성을 역전 시켰다고 말한다.
			- 왜냐하면 충전기가 C 타입이라는 인터페이스를 의존하게 되었기 때문
